<!doctype html><html lang=en-us><head><meta charset=utf-8><title>Heeus Prototype Performance Tests, Nov 2020</title><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="How we was making the Heeus prototype tests, benchmarking, comparison with regerence application written on Golang"><meta name=generator content="Hugo 0.82.1"><link rel=stylesheet href=https://heeus.io/plugins/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://heeus.io/plugins/themify-icons/themify-icons.css><link rel=stylesheet href=https://heeus.io/plugins/magnific-popup/magnific-popup.css><link rel=stylesheet href=https://heeus.io/plugins/slick/slick.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Anaheim%7cQuattrocento+Sans:400,700&display=swap"><link rel=stylesheet href=https://heeus.io/css/style.min.css media=screen><link rel=stylesheet href=https://heeus.io/css/custom.min.css media=screen><link rel="shortcut icon" href=https://heeus.io/images/favicon.png type=image/x-icon><link rel=icon href=https://heeus.io/images/favicon.png type=image/x-icon><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Noto+Sans&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=PT+Sans&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100&display=swap" rel=stylesheet></head><body id=body data-spy=scroll data-target=.navbar data-offset=55><div id=content><section class="sticky-top navigation"><div class=container><nav class="navbar navbar-expand-lg navbar-dark"><a class="navbar-brand p-0" href=/><img class=lozad data-src=https://heeus.io/images/logo.png alt="Heeus - Cloud Application Platform" height=42></a>
<button class="navbar-toggler rounded-0" type=button data-toggle=collapse data-target=#navigation>
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navigation><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://heeus.io></a></li></ul><select id=select-language onchange="location=this.value"><option id=en value=https://heeus.io/blog/en-performance-202011/ selected>En</option></select></div></nav></div></section><section class=section><div class=container><div class=row><div class="col-lg-8 offset-lg-2 text-center"><h1>Heeus Prototype Performance Tests, Nov 2020</h1><ul class="list-inline mb-50"><li class=list-inline-item><a href=/author/michael-saigachenko-heeus-team/>Michael Saigachenko, Heeus Team</a></li><li class=list-inline-item>11-13-2020</li></ul><div class=post-img-row><div class="post-img mb-50"><img class="img-fluid lozad" data-src=https://heeus.io/images/blog/performance-1.png alt=blog-image></div></div></div><div class="col-lg-8 offset-lg-2"><div class=post-single-content><h2 id=introduction>Introduction</h2><p>This article describes some details of preparation, methodology and results of performance testing of the &ldquo;insert&rdquo;, &ldquo;read&rdquo; and &ldquo;update&rdquo; operations. We were benchmarking the Heeus prototype driven application and compared it to the results of reference-application. We used <a href=https://cassandra.apache.org>Apache Cassandra</a> DBMS as the target database.</p><h2 id=reference-application>Reference application</h2><p>For the tests and benchmarks we developed a simple application on Golang, accepting JSON requests for doing CRU operations, and returning responses.
Web-server is based on the embedded net/http library. No other logic is done by the test application. Two instances of the test application launched in the cluster, and Nginx used as the request balancer.</p><h2 id=heeus-driven-application>Heeus-driven application</h2><p>Heeus-driven application is developed and compiled using Heeus framework on Golang. It does the same CRU operations into the same DBMS.
Heeus has its own requests balancer so it&rsquo;s installed on the same bastion host together with Nginx.</p><h2 id=infrastructure>Infrastructure</h2><p>When the testing began, we already had the tool for automatic cluster building developed. It is based on the cluster meta-description: structure, functions, settings. The tool generates the set of Terraform-config files, then the infrastructure prepared in <a href=https://aws.amazon.com/>Amazon AWS</a>: a public network, and a private networks, one for every configured datacenter (for the testing purposes we used a single datacenter), instances of desired configuration. Then the instances are pre-configured with the required software and tests run. Types of instances are the following:</p><ul><li>In a public network:<ul><li>bastion (router, balancer);</li><li>test node - which runs the application bombing the router with the requests;</li></ul></li><li>In private networks:<ul><li>DBMS;</li><li>worker node (instance which executes services).</li></ul></li></ul><p>In every test described in this article, we used three <a href="https://aws.amazon.com/ec2/instance-types/?nc1=h_ls">i3.xlarge</a> instances with Cassandra servers launched.
Database files are stored on NVMe SSD drives. Replication factor is 3, Consistency level is 2. Types and number of instances for every particular test will be described below. For the tests on every instance we used Ubuntu 18.04 (образ ami-0b7937aeb16a7eb94: ubuntu-bionic-18.04-amd64-server-20200112) image.</p><h2 id=testing-methodology>Testing methodology</h2><p>On the test node a series of tests launched: every test is an imitation of different load levels on the complete system. The load level is set
by the number of attacker threads (attackers): 40, 60, 100, 150, 250, 400, 600, 900, 1200, 1800. The balancer is under attack for some time, and during this time the system metrics are collected: performance (operations per second), latency, CPU loading on every node, etc.</p><p>At the beginning, we were going to use the <a href=https://github.com/brianfrankcooper/YCSB>YCSB</a> package to do the tests. However, we decided not to use it after some time, and developed the tool for testing by ourselves, using Golang. Why did we do so? First, YCSB requires JVM which is quite longer to deploy and launch than we would like it to have. Second, and we were surprised with that, YCSB wasn&rsquo;t good enough in performance for our tests. Finally, we developed the lightweight tool which is very similar in use, but only provides functions we need for testing.</p><h3 id=testing-details>Testing details</h3><ul><li>Reference application and Heeus app works with the different keyspaces in database</li><li>Insert tests: 500 000 records are written with unique keys. Every record has a size of about 1 Kb in total.</li><li>Before read and update tests, 500 000 records are inserted, then read/update tests are performed on the base of these records.</li><li>Heeus &ldquo;from the box&rdquo; provides high data consistency for the update operations. It would be incorrect to compare this kind of operations with the simple CQL UPDATE in Cassandra, so the reference application performs update using <a href=https://docs.datastax.com/en/archived/cql/3.3/cql/cql_using/useInsertLWT.html>LWT transactions</a>: <code>UPDATE ... IF ...</code>.</li></ul><h3 id=results-interpretation>Results interpretation</h3><ul><li>All the metrics were collected, handled and presented as charts, for better representation</li><li>For performance calculation only successfully finished operations were counted</li><li>The CPU-load of the certain node is actually the average CPU-load of all instances of the same type (f.e. worker node) during the complete test.</li></ul><h2 id=results-insert>Results: insert</h2><p>Cluster nodes:</p><table><thead><tr><th>Node</th><th>Number</th><th>AWS Instance Type</th></tr></thead><tbody><tr><td>bastion</td><td>1</td><td>c5.2xlarge</td></tr><tr><td>test node</td><td>1</td><td>c5.2xlarge</td></tr><tr><td>worker node</td><td>2</td><td>c5.xlarge</td></tr><tr><td>DB</td><td>3</td><td>i3.xlarge</td></tr></tbody></table><p><img src=/ru/images/blog/performance-202011/insert/rps.jpg alt="Insert performance test: operations per second">
Fig. 1: Insert performance test: operations per second</p><p><img src=/ru/images/blog/performance-202011/insert/latency.jpg alt="Insert performance test: latency">
Fig. 2: Insert performance test: latency</p><p>You can see that when load is low, the reference app and the heeus app shows similar performance, but as the number of attackers grows, Heeus app shows better figures. This refers both to the requests per second and the latency. Here&rsquo;s the figures for CPU loading of the cluster nodes:</p><p><img src=/ru/images/blog/performance-202011/insert/db_cpu.jpg alt="Insert performance test: DBMS CPU load">
Fig. 3: Insert performance test: DBMS CPU load</p><p><img src=/ru/images/blog/performance-202011/insert/router_cpu.jpg alt="Insert performance test: Router CPU load">
Fig. 4: Insert performance test: Router CPU load</p><p>Heeus balancer CPU load is a little bigger - 16% while reference balancer has 10%. But in the same time Heeus router handles 3 times more requests!</p><p><img src=/ru/images/blog/performance-202011/insert/worker_cpu.jpg alt="Insert performance test: Worker CPU load">
Fig. 5: Insert performance test: Worker CPU load</p><p>Heeus app handles much more operations per second than the reference app, but the CPU load is about the same.</p><h2 id=results-update>Results: update</h2><p>Cluster nodes:</p><table><thead><tr><th>Node</th><th>Number</th><th>AWS Instance Type</th></tr></thead><tbody><tr><td>bastion</td><td>1</td><td>c5.2xlarge</td></tr><tr><td>test node</td><td>1</td><td>c5.2xlarge</td></tr><tr><td>worker node</td><td>2</td><td>c5.xlarge</td></tr><tr><td>DB</td><td>3</td><td>i3.xlarge</td></tr></tbody></table><p><img src=/ru/images/blog/performance-202011/update/rps_1.jpg alt="Update performance test: operations per second">
Fig. 6: Update performance test: operations per second</p><p><img src=/ru/images/blog/performance-202011/update/latency_1.jpg alt="Update performance test: latency">
Fig. 7: Update performance test: latency</p><p>On the charts above you can see the difference, but the exact figures aren&rsquo;t clear. Below are the the charts for the same test, but using the logarithmic vertical scale, and the data tags:</p><p><img src=/ru/images/blog/performance-202011/update/rps_2.jpg alt="Update performance test: operations per second, logarithmic scale">
Fig. 8: Update performance test: operations per second, logarithmic scale</p><p><img src=/ru/images/blog/performance-202011/update/latency_2.jpg alt="Update performance test: latency, logarithmic scale">
Fig. 9: ![Update performance test: latency, logarithmic scale</p><p>You can see how bad the reference application is, as the number attackers grows. Of course, if it wouldn&rsquo;t be LWT, we saw the figures which is about similar to the previous test. But we had to use it, because Heeus app has the high data consistency for the update operations from the box.</p><p><img src=/ru/images/blog/performance-202011/update/db_cpu.jpg alt="Update performance test: DBMS CPU load">
Fig. 10: Update performance test: DBMS CPU load</p><p><img src=/ru/images/blog/performance-202011/update/router_cpu.jpg alt="Update performance test: router CPU load">
Fig. 11: Update performance test: router CPU load</p><p><img src=/ru/images/blog/performance-202011/update/worker_cpu.jpg alt="Update performance test: worker CPU load">
Fig. 12: Update performance test: worker CPU load</p><h2 id=results-read>Results: read</h2><p>Cluster nodes:</p><table><thead><tr><th>Node</th><th>Number</th><th>AWS Instance Type</th></tr></thead><tbody><tr><td>bastion</td><td>1</td><td>c5.4xlarge</td></tr><tr><td>test node</td><td>1</td><td>c5.4xlarge</td></tr><tr><td>worker node</td><td>2</td><td>c5.4large</td></tr><tr><td>DB</td><td>3</td><td>i3.xlarge</td></tr></tbody></table><p><img src=/ru/images/blog/performance-202011/read/rps.jpg alt="Read performance test: operations per second">
Fig. 13: Read performance test: operations per second</p><p><img src=/ru/images/blog/performance-202011/read/latency.jpg alt="Read performance test: latency">
Fig. 14: Read performance test: latency</p><p>Such a huge difference can be explained by the optimizations of the Heeus engine out-of-the-box: embedded caching, and others.
Look on the CPU load charts:</p><p><img src=/ru/images/blog/performance-202011/read/db_cpu.jpg alt="Read performance test: DBMS CPU load">
Fig. 15: Read performance test: DBMS CPU load</p><p><img src=/ru/images/blog/performance-202011/read/router_cpu.jpg alt="Read performance test: router CPU load">
Fig. 16: Read performance test: router CPU load</p><p><img src=/ru/images/blog/performance-202011/read/worker_cpu.jpg alt="Read performance test: worker CPU load">
Fig. 17: Read performance test: worker CPU load</p><p>On the DBMS CPU load chart you can see that the cache is being warmed-up during the few initial tests, then the CPU load is getting lower and lower, until it is almost zero, because there&rsquo;s no need to read from DB anymore</p><h2 id=conclusion>Conclusion</h2><p>On the current stage of development, Heeus figures much better than the ones for reference application. Due to effective architecture and many optimizations, Heeus provides highload features for the cloud applications out-of-the-box.</p></div><div class=text-center><a class="btn btn-transparent" href=javascript:history.back()>Go back</a></div><div class=mt-5></div></div></div></div></section></div><footer id=footer class=section-bg><div class=container><div class="row wow fadeInUp" data-wow-duration=500ms><div class=col-xl-12><div class="copyright text-center"><a href=https://heeus.io/><img src=https://heeus.io/images/logo.png alt="Heeus - Cloud Application Platform" height=42></a><br><p>Copyright © 2020-2021 Heeus Authors</p></div></div></div></div></footer><script src=https://heeus.io/plugins/jquery/jquery.min.js></script><script src=https://heeus.io/plugins/bootstrap/bootstrap.min.js></script><script src=https://heeus.io/plugins/slick/slick.min.js></script><script src=https://heeus.io/plugins/shuffle/shuffle.min.js></script><script src=https://heeus.io/plugins/magnific-popup/jquery.magnific-popup.min.js></script><script src=https://heeus.io/plugins/lazy-load/lozad.min.js></script><script src=https://heeus.io/plugins/google-map/map.js></script><script src=https://heeus.io/js/script.min.dfda07d67e5db1f94983c10b2d63fffe981b4255494e79874f525fe100789ebb633dfc9a4d787ca1cae962ef83ea91d5.js integrity=sha384-39oH1n5dsflJg8ELLWP//pgbQlVJTnmHT1Jf4QB4nrtjPfyaTXh8ocrpYu+D6pHV></script></body></html>