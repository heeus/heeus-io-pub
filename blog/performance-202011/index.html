<!doctype html><html lang=en-us><head><meta charset=utf-8><title>Voedger Prototype Performance Tests, Nov 2020</title><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="How we was making the Voedger prototype tests, benchmarking, comparison with regerence application written on Golang"><meta name=author content="Michael Saigachenko"><meta name=generator content="Hugo 0.110.0"><style>:root{--primary-color:#1a1725}</style><link rel=stylesheet href=https://heeus.io/plugins/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://heeus.io/plugins/themify-icons/themify-icons.css><link rel=stylesheet href=https://heeus.io/plugins/fontawesome/css/all.min.css><link rel=stylesheet href=https://heeus.io/css/style.min.css media=screen><link rel=stylesheet href=https://heeus.io/css/h_anim.min.css media=screen><link rel=stylesheet href=https://heeus.io/css/h_style.min.css media=screen><link rel="shortcut icon" href=https://heeus.io/images/favicon.png type=image/x-icon><link rel=icon href=https://heeus.io/images/favicon.png type=image/x-icon><script async src="https://www.googletagmanager.com/gtag/js?id=G-GR70V4BFWQ"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-GR70V4BFWQ")</script></head><body><header class="navigation fixed-top nav-bg"><nav class="navbar navbar-expand-lg navbar-dark"><a class=navbar-brand href=https://heeus.io/><img src=https://heeus.io/images/voedger.png alt="Voedger: Distributed Cloud Application Platform" id=mainlogo></a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navigation aria-controls=navigation aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse text-center" id=navigation><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://heeus.io/>Home</a></li><li class=nav-item><a class=nav-link href=https://docs.heeus.io>Documentation</a></li><li class=nav-item><a class=nav-link href=https://heeus.io/about>About</a></li></ul></div></nav></header><section class=section2><div class=container><div class="row justify-content-center"><div class="col-lg-9 text-center mb-4"><img src=https://heeus.io/images/blog/performance-1.png alt="Voedger Prototype Performance Tests, Nov 2020" class="img-fluid rounded mb-4 blogtitleimg"><p class=font-secondary>Published on Nov 13, 2020 by <span class=text-primary>Michael Saigachenko</span></p></div><div class=col-lg-9><div class=content><h2 id=introduction>Introduction</h2><p>This article describes some details of preparation, methodology and results of performance testing of the &ldquo;insert&rdquo;, &ldquo;read&rdquo; and &ldquo;update&rdquo; operations. We were benchmarking the Voedger prototype driven application and compared it to the results of reference-application. We used <a href=https://cassandra.apache.org>Apache Cassandra</a> DBMS as the target database.</p><h2 id=reference-application>Reference application</h2><p>For the tests and benchmarks we developed a <a href=https://github.com/heeus/reference-crud-app>simple application</a> on Golang, accepting JSON requests for doing CRU operations, and returning responses.<br>Web-server is based on the embedded net/http library. No other logic is done by the test application. Two instances of the test application launched in the cluster, and Nginx used as the request balancer.</p><h2 id=voedger-driven-application>Voedger-driven application</h2><p>Voedger-driven application is developed and compiled using Voedger framework on Golang. It does the same CRU operations into the same DBMS.<br>Voedger has its own requests balancer so it&rsquo;s installed on the same bastion host together with Nginx.</p><h2 id=infrastructure>Infrastructure</h2><p>When the testing began, we already had the tool for automatic cluster building developed. It is based on the cluster meta-description: structure, functions, settings. The tool generates the set of Terraform-config files, then the infrastructure prepared in <a href=https://aws.amazon.com/>Amazon AWS</a>: a public network, and a private networks, one for every configured datacenter (for the testing purposes we used a single datacenter), instances of desired configuration. Then the instances are pre-configured with the required software and tests run. Types of instances are the following:</p><ul><li>In a public network:<ul><li>bastion (router, balancer);</li><li>test node - which runs the application bombing the router with the requests;</li></ul></li><li>In private networks:<ul><li>DBMS;</li><li>worker node (instance which executes services).</li></ul></li></ul><p>In every test described in this article, we used three <a href="https://aws.amazon.com/ec2/instance-types/?nc1=h_ls">i3.xlarge</a> instances with Cassandra servers launched.<br>Database files are stored on NVMe SSD drives. Replication factor is 3, Consistency level is 2. Types and number of instances for every particular test will be described below. For the tests on every instance we used Ubuntu 18.04 (ami-0b7937aeb16a7eb94: ubuntu-bionic-18.04-amd64-server-20200112 image).</p><h2 id=testing-methodology>Testing methodology</h2><p>On the test node a series of tests launched: every test is an imitation of different load levels on the complete system. The load level is set<br>by the number of attacker threads (attackers): 40, 60, 100, 150, 250, 400, 600, 900, 1200, 1800. The balancer is under attack for some time, and during this time the system metrics are collected: performance (operations per second), latency, CPU loading on every node, etc.</p><p>At the beginning, we were going to use the <a href=https://github.com/brianfrankcooper/YCSB>YCSB</a> package to do the tests. However, we decided not to use it after some time, and developed the tool for testing by ourselves, using Golang. Why did we do so? First, YCSB requires JVM which is quite longer to deploy and launch than we would like it to have. Second, and we were surprised with that, YCSB wasn&rsquo;t good enough in performance for our tests. Finally, we developed the lightweight tool which is very similar in use, but only provides functions we need for testing.</p><h3 id=testing-details>Testing details</h3><ul><li>Reference application and Voedger app works with the different keyspaces in database</li><li>Insert tests: 500 000 records are written with unique keys. Every record has a size of about 1 Kb in total.</li><li>Before read and update tests, 500 000 records are inserted, then read/update tests are performed on the base of these records.</li><li>Voedger &ldquo;from the box&rdquo; provides high data consistency for the update operations. It would be incorrect to compare this kind of operations with the simple CQL UPDATE in Cassandra, so the reference application performs update using <a href=https://docs.datastax.com/en/archived/cql/3.3/cql/cql_using/useInsertLWT.html>LWT transactions</a>: <code>UPDATE ... IF ...</code>.</li></ul><h3 id=results-interpretation>Results interpretation</h3><ul><li>All the metrics were collected, handled and presented as charts, for better representation</li><li>For performance calculation only successfully finished operations were counted</li><li>The CPU-load of the certain node is actually the average CPU-load of all instances of the same type (f.e. worker node) during the complete test.</li></ul><h2 id=results-insert>Results: insert</h2><p>Cluster nodes:</p><table><thead><tr><th>Node</th><th>Number</th><th>AWS Instance Type</th></tr></thead><tbody><tr><td>bastion</td><td>1</td><td>c5.2xlarge</td></tr><tr><td>test node</td><td>1</td><td>c5.2xlarge</td></tr><tr><td>worker node</td><td>2</td><td>c5.xlarge</td></tr><tr><td>DB</td><td>3</td><td>i3.xlarge</td></tr></tbody></table><p><img src=/images/blog/performance-202011/insert/rps.jpg alt="Insert performance test: operations per second"><br><div style=text-align:center;margin-top:-1.5rem;margin-bottom:2rem>Fig. 1: Insert performance test: operations per second</div></p><p><img src=/images/blog/performance-202011/insert/latency.jpg alt="Insert performance test: latency"><br><div style=text-align:center;margin-top:-1.5rem;margin-bottom:2rem>Fig. 2: Insert performance test: latency</div></p><p>You can see that when load is low, the reference app and the Voedger app shows similar performance, but as the number of attackers grows, Voedger app shows better figures. This refers both to the requests per second and the latency. Here&rsquo;s the figures for CPU loading of the cluster nodes:</p><p><img src=/images/blog/performance-202011/insert/db_cpu.jpg alt="Insert performance test: DBMS CPU load"><br><div style=text-align:center;margin-top:-1.5rem;margin-bottom:2rem>Fig. 3: Insert performance test: DBMS CPU load</div></p><p><img src=/images/blog/performance-202011/insert/router_cpu.jpg alt="Insert performance test: Router CPU load"><br><div style=text-align:center;margin-top:-1.5rem;margin-bottom:2rem>Fig. 4: Insert performance test: Router CPU load</div></p><p>Voedger balancer CPU load is a little bigger - 16% while reference balancer has 10%. But in the same time Voedger router handles 3 times more requests!</p><p><img src=/images/blog/performance-202011/insert/worker_cpu.jpg alt="Insert performance test: Worker CPU load"><br><div style=text-align:center;margin-top:-1.5rem;margin-bottom:2rem>Fig. 5: Insert performance test: Worker CPU load</div></p><p>Voedger app handles much more operations per second than the reference app, but the CPU load is about the same.</p><h2 id=results-update>Results: update</h2><p>Cluster nodes:</p><table><thead><tr><th>Node</th><th>Number</th><th>AWS Instance Type</th></tr></thead><tbody><tr><td>bastion</td><td>1</td><td>c5.2xlarge</td></tr><tr><td>test node</td><td>1</td><td>c5.2xlarge</td></tr><tr><td>worker node</td><td>2</td><td>c5.xlarge</td></tr><tr><td>DB</td><td>3</td><td>i3.xlarge</td></tr></tbody></table><p><img src=/images/blog/performance-202011/update/rps_1.jpg alt="Update performance test: operations per second"><br><div style=text-align:center;margin-top:-1.5rem;margin-bottom:2rem>Fig. 6: Update performance test: operations per second</div></p><p><img src=/images/blog/performance-202011/update/latency_1.jpg alt="Update performance test: latency"><br><div style=text-align:center;margin-top:-1.5rem;margin-bottom:2rem>Fig. 7: Update performance test: latency</div></p><p>On the charts above you can see the difference, but the exact figures aren&rsquo;t clear. Below are the the charts for the same test, but using the logarithmic vertical scale, and the data tags:</p><p><img src=/images/blog/performance-202011/update/rps_2.jpg alt="Update performance test: operations per second, logarithmic scale"><br><div style=text-align:center;margin-top:-1.5rem;margin-bottom:2rem>Fig. 8: Update performance test: operations per second, logarithmic scale</div></p><p><img src=/images/blog/performance-202011/update/latency_2.jpg alt="Update performance test: latency, logarithmic scale"><br><div style=text-align:center;margin-top:-1.5rem;margin-bottom:2rem>Fig. 9: Update performance test: latency, logarithmic scale</div></p><p>You can see how bad the reference application is, as the number attackers grows. Of course, if it wouldn&rsquo;t be LWT, we saw the figures which is about similar to the previous test. But we had to use it, because Voedger app has the high data consistency for the update operations from the box.</p><p><img src=/images/blog/performance-202011/update/db_cpu.jpg alt="Update performance test: DBMS CPU load"><br><div style=text-align:center;margin-top:-1.5rem;margin-bottom:2rem>Fig. 10: Update performance test: DBMS CPU load</div></p><p><img src=/images/blog/performance-202011/update/router_cpu.jpg alt="Update performance test: router CPU load"><br><div style=text-align:center;margin-top:-1.5rem;margin-bottom:2rem>Fig. 11: Update performance test: router CPU load</div></p><p><img src=/images/blog/performance-202011/update/worker_cpu.jpg alt="Update performance test: worker CPU load"><br><div style=text-align:center;margin-top:-1.5rem;margin-bottom:2rem>Fig. 12: Update performance test: worker CPU load</div></p><h2 id=results-read>Results: read</h2><p>Cluster nodes:</p><table><thead><tr><th>Node</th><th>Number</th><th>AWS Instance Type</th></tr></thead><tbody><tr><td>bastion</td><td>1</td><td>c5.4xlarge</td></tr><tr><td>test node</td><td>1</td><td>c5.4xlarge</td></tr><tr><td>worker node</td><td>2</td><td>c5.4large</td></tr><tr><td>DB</td><td>3</td><td>i3.xlarge</td></tr></tbody></table><p><img src=/images/blog/performance-202011/read/rps.jpg alt="Read performance test: operations per second"><br><div style=text-align:center;margin-top:-1.5rem;margin-bottom:2rem>Fig. 13: Read performance test: operations per second</div></p><p><img src=/images/blog/performance-202011/read/latency.jpg alt="Read performance test: latency"><br><div style=text-align:center;margin-top:-1.5rem;margin-bottom:2rem>Fig. 14: Read performance test: latency</div></p><p>Such a huge difference can be explained by the optimizations of the Voedger engine out-of-the-box: embedded caching, and others.<br>Look on the CPU load charts:</p><p><img src=/images/blog/performance-202011/read/db_cpu.jpg alt="Read performance test: DBMS CPU load"><br><div style=text-align:center;margin-top:-1.5rem;margin-bottom:2rem>Fig. 15: Read performance test: DBMS CPU load</div></p><p><img src=/images/blog/performance-202011/read/router_cpu.jpg alt="Read performance test: router CPU load"><br><div style=text-align:center;margin-top:-1.5rem;margin-bottom:2rem>Fig. 16: Read performance test: router CPU load</div></p><p><img src=/images/blog/performance-202011/read/worker_cpu.jpg alt="Read performance test: worker CPU load"><br><div style=text-align:center;margin-top:-1.5rem;margin-bottom:2rem>Fig. 17: Read performance test: worker CPU load</div></p><p>On the DBMS CPU load chart you can see that the cache is being warmed-up during the few initial tests, then the CPU load is getting lower and lower, until it is almost zero, because there&rsquo;s no need to read from DB anymore</p><h2 id=conclusion>Conclusion</h2><p>On the current stage of development, Voedger figures much better than the ones for reference application. Due to effective architecture and many optimizations, Voedger provides highload features for the cloud applications out-of-the-box.</p></div></div></div></div></section><aside class=blogtoc><header><h5>Voedger Prototype Performance Tests, Nov 2020</h5></header><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#reference-application>Reference application</a></li><li><a href=#voedger-driven-application>Voedger-driven application</a></li><li><a href=#infrastructure>Infrastructure</a></li><li><a href=#testing-methodology>Testing methodology</a><ul><li><a href=#testing-details>Testing details</a></li><li><a href=#results-interpretation>Results interpretation</a></li></ul></li><li><a href=#results-insert>Results: insert</a></li><li><a href=#results-update>Results: update</a></li><li><a href=#results-read>Results: read</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></aside><footer class="bg-dark footer-section"><div class=section><div class=container><div class=row><div class=col-md-4><h5 class=text-light>Email</h5><p class="text-white paragraph-lg font-secondary"><a href=mailto:contact@heeus.io>contact@heeus.io</a></p></div><div class=col-md-4><h5 class=text-light>Phone</h5><p class="text-white paragraph-lg font-secondary"><a href=tel:+123%20456%20789%20000>+123 456 789 000</a></p></div><div class=col-md-4><h5 class=text-light>Telegram</h5><p class="text-white paragraph-lg font-secondary">https://t.me/heeuslive</p></div></div></div></div><div class="footer-bottom border-top text-center border-dark py-5"><p class="mb-0 text-light">Copyright © 2022 Voedger Authors</p></div></footer><script src=https://heeus.io/plugins/jQuery/jquery.min.js></script>
<script src=https://heeus.io/plugins/bootstrap/bootstrap.min.js></script>
<script src=https://heeus.io/js/script.min.js></script></body></html>